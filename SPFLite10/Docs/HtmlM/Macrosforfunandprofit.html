

<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="generator" content="HelpNDoc Personal Edition 5.9.0.711">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="favicon.ico"/>

  <title>Macros for fun and profit</title>
  <meta name="description" content="" /> 
  <meta name="keywords" content="">



  

  <!-- Twitter Card data -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Macros for fun and profit">
  <meta name="twitter:description" content="">

  <!-- Open Graph data -->
  <meta property="og:title" content="Macros for fun and profit" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="" />
  <meta property="og:site_name" content="SPFLite Edit Macros - V10.1.8351 - 2018-12-16" /> 

  <!-- Bootstrap core CSS -->
  <link href="vendors/bootstrap-3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

  <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
  <link href="vendors/bootstrap-3.3.6/css/ie10-viewport-bug-workaround.css" rel="stylesheet"/>

  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
      <script src="vendors/html5shiv-3.7.2/html5shiv.min.js"></script>
      <script src="vendors/respond-1.4.2/respond.min.js"></script>
    <![endif]-->

  <!-- JsTree styles -->
  <link href="vendors/jstree-3.3.2/themes/default/style.min.css" rel="stylesheet"/>

  <!-- Hnd styles -->
  <link href="css/layout.min.css" rel="stylesheet" />
  <link href="css/effects.min.css" rel="stylesheet" />
  <link href="css/theme-light-blue.min.css" rel="stylesheet" />
  <link href="css/print.min.css" rel="stylesheet" media="print" />
  <style type="text/css">nav { width: 350px} @media screen and (min-width:769px) { body.md-nav-expanded div#main { margin-left: 350px} body.md-nav-expanded header { padding-left: 364px} }</style>

  <!-- Content style -->
  <link href="css/hnd.content.css" rel="stylesheet" />

  



</head>

<body class="md-nav-expanded">



  <div id="skip-link">
    <a href="#main-content" class="element-invisible">Skip to main content</a>
  </div>

  <header class="headroom">
    <button class="hnd-toggle btn btn-default">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span>        
    </button>
    <h1>SPFLite Edit Macros - V10.1.8351 - 2018-12-16</h1>
    
  </header>

  <nav class="md-nav-expanded">
    <!-- Nav tabs -->
    <ul class="tab-tabs nav nav-tabs" role="tablist">
      <li id="nav-close"> 
        <button class="hnd-toggle btn btn-default">
          <span class="glyphicon glyphicon-remove" aria-hidden="true"></span>
        </button>
      </li>
      
	  
        <li role="presentation" class="tab active">
            <a href="#contents" id="tab-contents" aria-controls="contents" role="tab" data-toggle="tab">
                <i class="glyphicon glyphicon-list"></i>
                Contents
            </a>
        </li>
      
    </ul>  <!-- /Nav tabs -->

    <!-- Tab panes -->
    <div class="tab-content">
	  
      <div role="tabpanel" class="tab-pane active" id="contents">
        <div id="toc" class="tree-container unselectable"
            data-url="_toc.json"
            data-openlvl="1"
        >
            
        </div>
      </div>  <!-- /contents-->
      
    </div>  <!-- /Tab panes -->

  </nav>

  <div id="main">

    <article>
        <div id="topic-content" class="container-fluid" 
		  data-hnd-id="Macrosforfunandprofit"
		  data-hnd-context="19"
		  data-hnd-title="Macros for fun and profit"
		>
            

            <a id="main-content"></a>

            <h2>Macros for fun and profit</h2>

            <div class="main-content">
                
<p></p>
<p class="rvps2"><span class="rvts13">A brief overview of macros</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">We have (somewhat whimsically) entitled this section, </span><span class="rvts33">Macros for fun and profit</span><span class="rvts11">. You might be persuaded that you could profit from using macros, but maybe you think you won't have much fun writing them. Let's see what we can do to change your mind !</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">Users sometimes feel that the whole topic of macros is too complicated, and they tend to steer clear of them, without even trying to see what they could accomplish by taking advantage of their capabilities.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">Are SPFLite macros really that complicated? &nbsp;Well, you could certainly </span><span class="rvts13">make</span><span class="rvts11"> them complicated if you were inclined to - but then that would be </span><span class="rvts13">your</span><span class="rvts11"> doing, and not SPFLite's fault!</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">There's actually not that much that is inherently "hard" about these macros, once you familiarize yourself with the </span><span class="rvts13">thinBasic</span><span class="rvts11"> syntax and features. It's really the same as with the rest of SPFLite itself, which has a large array of primary and line commands and keyboard functions at your disposal. That doesn't necessarily make it "hard". It just means you have a lot of tools that you </span><span class="rvts13">could</span><span class="rvts11"> use if you needed them. The specific commands you use, and how you use them, are driven by your requirements, which in turn are driven by the nature of the data you are creating or modifying.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">The same is true with macros. A given macro is really only as complicated as the editing task you are trying to carry out. A trivial task can be done with a trivial macro, but a very complex task calls for an involved macro.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps5"><span class="rvts11">That's only fair. If you wrote some external script in Perl, Rexx or C++ to do a complex editing process, </span><span class="rvts13">that</span><span class="rvts11"> would be involved, too. This is computation - not magic. You can't get something for nothing.</span></p>
<p class="rvps5"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">So, the main point is: </span><span class="rvts33">don't panic</span><span class="rvts11">. Most SPFLite users that create macros will probably only need relatively short scripts. But, the tools and features are there to do really cool and complicated things - </span><span class="rvts13">if</span><span class="rvts11"> that's what you need and want to do.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">Let's try and show you how straightforward a macro can be. The best way to do that is with an example, so let's choose a simple one that you should find easy to understand.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps2"><span class="rvts13">Example: The ONLY macro</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">The ONLY macro implements a two-step SPFLite command sequence:</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps7"><span class="rvts18">EXCLUDE ALL</span></p>
<p class="rvps7"><span class="rvts18">FIND ALL </span><span class="rvts34">string</span></p>
<p class="rvps4"><span class="rvts13"><br/></span></p>
<p class="rvps4"><span class="rvts11">This changes the display to show ONLY those text lines containing a specified </span><span class="rvts33">string.</span></p>
<p class="rvps4"><span class="rvts33"><br/></span></p>
<p class="rvps5"><span class="rvts11">In the "good old days" of SPFLite 1.0, as well as in other editors like ISPF, early Tritus SPF, and SPF/SE, this is the only way you </span><span class="rvts13">could</span><span class="rvts11"> do that. SPFLite presently allows you perform this function directly using the built-in command NEXCLUDE. But, bear with us - imagine that SPFLite </span><span class="rvts13">didn't</span><span class="rvts11"> have this command built in, but you needed to do it anyway. After all, eventually you </span><span class="rvts13">will</span><span class="rvts11"> find some task you need to do that SPFLite doesn't do directly, and then you really will need a macro.</span></p>
<p class="rvps4"><span class="rvts33"><br/></span></p>
<p class="rvps4"><span class="rvts11">What we need is to create a macro which will perform these two commands after we enter the command &nbsp;</span><span class="rvts18">ONLY </span><span class="rvts34">string</span><span class="rvts14">. </span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps5"><span class="rvts11">Why can't we just enter the commands themselves directly, like we could do in those "good old days" when SPFLite only supported simple </span><span class="rvts18">.SPM</span><span class="rvts11"> macros? &nbsp;It's because these programmable macros are not merely "dumb" command lines, but are full-fledged programming statements written in the </span><span class="rvts13">thinBasic</span><span class="rvts11"> language. </span><span class="rvts13">Everything</span><span class="rvts11"> you write in an SPFLite programmable macro must conform to the syntax and language rules of </span><span class="rvts13">thinBasic</span><span class="rvts11">.</span></p>
<p class="rvps7"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">Invoking SPFLite commands within a macro is done by calling a function designed for this purpose, the </span><span class="rvts18">SPF_Cmd</span><span class="rvts14"> </span><span class="rvts11">function, which is used like this:</span></p>
<p class="rvps7"><span class="rvts14"><br/></span></p>
<p class="rvps7"><span class="rvts18">SPF_Cmd("some SPFLite primary command")</span></p>
<p class="rvps4"><span class="rvts18"><br/></span></p>
<p class="rvps4"><span class="rvts11">The command you specify can be any valid thinBasic string expression, but for now we'll start with simple string literals.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps5"><span class="rvts11">By the way, in the example above, "some SPFLite </span><span class="rvts13">primary</span><span class="rvts11"> command" means that you can't (directly) enter </span><span class="rvts13">line</span><span class="rvts11"> commands using this function. However, you </span><span class="rvts13">can</span><span class="rvts11"> use the </span><span class="rvts13">LINE</span><span class="rvts11"> primary command to achieve the same thing. See the LINE primary command in the main Help documentation for more information.</span></p>
<p class="rvps7"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">So, what we want to create is a macro script containing the lines</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps7"><span class="rvts18">SPF_Cmd("EXCLUDE ALL")</span></p>
<p class="rvps7"><span class="rvts18">SPF_Cmd("FIND ALL XXX")</span></p>
<p class="rvps7"><span class="rvts14"><br/></span></p>
<p class="rvps4"><span class="rvts11">Let's do that, and create the file </span><span class="rvts18">ONLY.MACRO</span><span class="rvts11"> in the SPFLite \MACROS folder.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps5"><span class="rvts11">FYI, if you're going to get in the business of creating and editing macros frequently, you may find it convenient to set up a FILELIST so you can see all of your macros in one place in the File Manager. See the FILELIST documentation in the main Help file for more information, but basically, simply create a file named MACROS.FILELIST containing the following two lines. Store in the SPFLite data directory.</span></p>
<p class="rvps5"><span class="rvts11"><br/></span></p>
<p class="rvps5"><span class="rvts11"> &nbsp; &nbsp;For XP it would be:</span></p>
<p class="rvps10"><span class="rvts14">FilePath: C:\Documents and Settings\username\My Documents\SPFLite\MACROS</span></p>
<p class="rvps10"><span class="rvts14">FileMask: *.*</span></p>
<p class="rvps13"><span class="rvts14"><br/></span></p>
<p class="rvps5"><span class="rvts11"> &nbsp; &nbsp;and for Win 7/8:</span></p>
<p class="rvps10"><span class="rvts14">FilePath: C:\Users\username\My Documents\SPFLite\MACROS</span></p>
<p class="rvps10"><span class="rvts14">FileMask: *.*</span></p>
<p class="rvps10"><span class="rvts14"><br/></span></p>
<p class="rvps4"><span class="rvts11">However, SPFLite has one additional requirement when creating a macro. The first line of it must be a macro prototype (or, </span><span class="rvts33">header</span><span class="rvts11">) statement, which takes the form of a thinBasic comment line in a special format. In our example, it requires little more than the name, and our macro now looks like this:</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps7"><span class="rvts18">' ONLY.MACRO</span></p>
<p class="rvps7"><span class="rvts18">SPF_Cmd("EXCLUDE ALL")</span></p>
<p class="rvps7"><span class="rvts18">SPF_Cmd("FIND ALL XXX")</span></p>
<p class="rvps7"><span class="rvts18"><br/></span></p>
<p class="rvps4"><span class="rvts11">That wasn't so bad, was it? </span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">Our macro is complete ... except that right now, it always does a FIND command for a literal string of "XXX". That "XXX" was just a place-holder, while we were busy trying to explain things and setting up the macro. But, we originally wanted to do a FIND operation that looked like </span><span class="rvts18">FIND ALL </span><span class="rvts34">string</span><span class="rvts11">, where </span><span class="rvts33">string</span><span class="rvts11"> is supplied on the primary command line - remember? &nbsp;Somehow, we need to create this command dynamically, so it includes </span><span class="rvts13">your</span><span class="rvts11"> string, and not just XXX all the time.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">To do that, we need to have the SPF_Cmd function accept a </span><span class="rvts33">string expression</span><span class="rvts11">, rather than a </span><span class="rvts33">string literal.</span><span class="rvts11"> &nbsp;So, let's make a simple change to our macro to do just that:</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps7"><span class="rvts18">' ONLY.MACRO</span></p>
<p class="rvps7"><span class="rvts18">SPF_Cmd("EXCLUDE ALL")</span></p>
<p class="rvps7"><span class="rvts18">SPF_Cmd("FIND ALL " + Get_Arg$(1))</span></p>
<p class="rvps7"><span class="rvts18"><br/></span></p>
<p class="rvps4"><span class="rvts11">Here, the string literal </span><span class="rvts14">"</span><span class="rvts18">FIND ALL</span><span class="rvts14"> "</span><span class="rvts11"> and the string returned by the function </span><span class="rvts18">Get_Arg$(1)</span><span class="rvts11"> are concatenated together to form a single string value. The </span><span class="rvts18">Get_Arg$(n)</span><span class="rvts11"> function returns the string contents of the specified argument number. The + plus sign is the string concatenation operator (you can also use &amp; ampersand if you like; they both mean the same thing). </span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps5"><span class="rvts11">Remember to put a blank after the "FIND ALL " string, like we did here. Otherwise, the ALL and the string you got back from Get_Arg$(1) would get "run together". If you did that, a macro command like ONLY ABC would cause the macro to create a command string expression like</span><span class="rvts18"> FIND ALLABC </span><span class="rvts11">which would either be illegal, or just not what you wanted.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">So now, if the command ONLY FRED were issued,</span><span class="rvts13"> </span><span class="rvts18">Get_Arg$(1)</span><span class="rvts11"> returns the string </span><span class="rvts14">"</span><span class="rvts18">FRED</span><span class="rvts14">"</span><span class="rvts11">, and so the two commands issued would effectively become:</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps7"><span class="rvts18">EXCLUDE ALL</span></p>
<p class="rvps7"><span class="rvts18">FIND ALL FRED</span></p>
<p class="rvps4"><span class="rvts18"><br/></span></p>
<p class="rvps4"><span class="rvts11">Exactly what we want!</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">But, suppose we want to include optional FIND operands like WORD or PREFIX or LAST. This is another simple change, and our final macro will now look like:</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps7"><span class="rvts18">' ONLY.MACRO</span></p>
<p class="rvps7"><span class="rvts18">SPF_Cmd("EXCLUDE ALL")</span></p>
<p class="rvps7"><span class="rvts18">SPF_Cmd("FIND ALL " + Get_Arg$(0))</span></p>
<p class="rvps7"><span class="rvts18"><br/></span></p>
<p class="rvps4"><span class="rvts11">Hmm, what's different? &nbsp;The </span><span class="rvts18">Get_Arg$(0)</span><span class="rvts11"> instead of </span><span class="rvts18">Get_Arg$(1)</span><span class="rvts11"> is a request for </span><span class="rvts13">all</span><span class="rvts11"> the operands, not just the first. (When you provide two or more macro operands to ONLY, the</span><span class="rvts13"> </span><span class="rvts18">Get_Arg$(0</span><span class="rvts14">)</span><span class="rvts11"> function returns all of them together, so they are separated from each other by a blank.) &nbsp;</span></p>
<p class="rvps4"><span class="rvts11">So, if the macro command ONLY FRED WORD were issued, the two commands issued would be:</span></p>
<p class="rvps4"><span class="rvts11"> </span></p>
<p class="rvps7"><span class="rvts18">EXCLUDE ALL</span></p>
<p class="rvps7"><span class="rvts18">FIND ALL FRED WORD</span></p>
<p class="rvps4"><span class="rvts18"><br/></span></p>
<p class="rvps4"><span class="rvts11">Not too shabby, eh?</span><span class="rvts14"> </span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps2"><span class="rvts13">Enhancing the ONLY macro to work in more than one context</span></p>
<p class="rvps2"><span class="rvts13"><br/></span></p>
<p class="rvps4"><span class="rvts11">Certainly, that was a fairly simple example, but like most macros, it grows once you start using it and think "It would be nice if ...". </span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">So, what more could we possibly do with this ONLY macro? &nbsp; Well, a lot of the time the ONLY macro would be issued while you were browsing a file and you saw some word of interest within the text. Why should we have to manually type in (or even cut and paste) a word on to the command line, when it's already sitting right there in the text? &nbsp; (There's something to be said for constructive laziness! - RH) &nbsp;Let's change ONLY so that it will use the word that's being pointed to by the cursor.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">This is also surprisingly easy. Our macro now becomes:</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps7"><span class="rvts18">' ONLY.MACRO</span></p>
<p class="rvps7"><span class="rvts18">SPF_Cmd("EXCLUDE ALL")</span></p>
<p class="rvps7"><span class="rvts18">SPF_Cmd("FIND ALL " + Get_Curr_Word$)</span></p>
<p class="rvps7"><span class="rvts14"><br/></span></p>
<p class="rvps4"><span class="rvts11">The </span><span class="rvts18">Get_Curr_Word$</span><span class="rvts14"> </span><span class="rvts11">function is designed specifically to address this need. It returns the 'word' that the cursor is sitting on, when the cursor is underneath some string in the data area of the edit window. Now, we can map a keyboard key (let's say, Ctrl-O) to ONLY and then all we need to do is place the cursor anywhere within a word and hit Ctrl-O.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">We now have a quite useful macro, and it is still only 3 lines long.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">However, we have now lost the ability to actually type in an&nbsp;</span><span class="rvts13"> </span><span class="rvts18">ONLY </span><span class="rvts34">string</span><span class="rvts14"> </span><span class="rvts11">command, since the macro now requires a word to be present under the cursor. If you are typing a command on the </span><span class="rvts13">command</span><span class="rvts11"> line, there isn't any file data under the cursor, because your cursor is not </span><span class="rvts13">in</span><span class="rvts11"> the data area. </span></p>
<p class="rvps4"><span class="rvts11">But, we don't want to give up the command-line usage. What we really need is a way to determine the macro's </span><span class="rvts13">context</span><span class="rvts11"> - that is, </span><span class="rvts13">how and where</span><span class="rvts11"> </span><span class="rvts13">the macro is being used</span><span class="rvts11">. Then, we tailor the macro to operate differently depending on how it's being used, and then we can use the same macro for more than one purpose.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts23"><br/></span></p>
<p class="rvps2"><span class="rvts13">Managing quoted operands</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">Before we put this new macro together, there is a little matter of quotes to deal with. If you recall from the basics of SPFLite, you can have quoted string values enclosed in ' single quotes, " double quotes or ` accent quotes, or simple strings can be supplied unquoted.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">You also need to be aware that keywords that are reserved elsewhere, like ALL and LAST, are </span><span class="rvts13">not</span><span class="rvts11"> reserved as operands of a macro used as a primary command.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">So, if you supply a macro argument that happens to be a keyword of some other SPFLite command, and you then use that string to dynamically create some command, it could create some invalid syntax. For example, without some "fancy footwork", if we tried to say ONLY FIRST, one of the created commands would be FIND ALL FIRST, and that's not legal.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">In your macro, you might be tempted to get around this by always putting quotes around the string you get back from a Get_ARG$ call. But, suppose, as a macro user, you actually placed quotes around a string, like ONLY "FIRST". If your macro added quotes, too, you'd have too many of them. So, if you issued a macro command like ONLY "FIRST" with quotes already around the operand, and the macro logic added quotes, too, you'd end up with a command like FIND ALL ""FIRST"" with improperly-doubled quotes - and that's not what you wanted.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">You </span><span class="rvts13">could</span><span class="rvts11"> check to see if the argument already had quotes on it, and tailor your expression accordingly, but that would be a real nuisance to do all the time. Fortunately, you don't have to. We have created a function called SPF_Quote$. What this does is it adds quotes to a string expression, unless it is already quoted, in which case it leaves it as is. It also takes into account whether a string contains inner quotes of any type, so that it wouldn't create a wrongly-quoted string. It does that by choosing one of the three allowable quote types, to avoid having the enclosing quotes be the same as any inner quotes which are literal data values. These actions make the function what we call a "smart quoter".</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">The example below uses the smart-quoter function to correctly create SPFLite command strings. Now, even if the operands you provide are already quoted or are SPFLite reserved words, the macro will still work properly.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">You would need this smart quoter function whether the operand was supplied on the command line or was obtained from a function like Get_Curr_Word$, because we have no way of knowing if the word under the cursor is reserved either.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps2"><span class="rvts13">Managing argument lists</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">When you use the ONLY macro, and it has multiple arguments, you can "grab" them all with a function. But if you needed to quote the search string AND you had additional arguments, how could you just quote the first one and not the rest of them? &nbsp;</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">This is going to take a little tinkering ... but we promise, it won't be too hard.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">First of all, you need to understand that macro parameter lists are </span><span class="rvts13">not</span><span class="rvts11"> like SPFLite command parameters. For example, a FIND command could say FIND ALL ABC or it could say FIND ABC ALL, and they both mean the same thing, because you can supply operands to most SPFLite commands in any order. SPFLite can tell which operands are reserved words and which are user-supplied values, and it sorts them out based on which command you used.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">Although Macros can be coded to handle operands this way, for the purposes of this discussion we will ignore that temporarily and keep things simple. If, following this discussion, you want to learn how to handle operands in that manner, review </span><a class="rvts12" href="AccessingCommandLineOperands.html#Full%20Parse%20Access">Full Parse Access</a><span class="rvts11">. </span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">With that in mind, we will agree to design the ONLY macro so that the </span><span class="rvts33">string</span><span class="rvts11"> operand is always the first one, meaning that you'd always use </span><span class="rvts18">Get_Arg$(1)</span><span class="rvts11"> to "grab" it. What about all the </span><span class="rvts33">other</span><span class="rvts11"> operands - if there are any? &nbsp;How do we grab them?</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">First, we take advantage of the special fact that Get_Arg$ can be called with either one or two arguments of its own. If called with two arguments, you provide a "range" of operands. So, if you wanted arguments 3 through 5, you could get them with </span><span class="rvts18">Get_Arg$(3,5)</span><span class="rvts11">.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps5"><span class="rvts11">You have to ask for arguments in ascending order. Calling </span><span class="rvts18">Get_Arg$(5,3)</span><span class="rvts11"> will return nothing (an empty string). And also trigger a failing RC value and associated error message if you cared to check and retrieve them.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">Second, if you read closely in the Function Details section, you'll find there is a function called </span><span class="rvts18">Get_Arg_Count</span><span class="rvts11">. So, assuming you wanted all arguments starting with the second one, you could say </span><span class="rvts18">Get_Arg$(2,Get_Arg_Count)</span><span class="rvts11">. That would work fine, but it's kind of wordy. Since it will be a common task to require "all remaining operands" this way, the function allows the second operand to be specified as </span><span class="rvts13">0</span><span class="rvts11">, with a call like </span><span class="rvts18">Get_Arg$(2,0)</span><span class="rvts11">. When you supply a </span><span class="rvts13">0</span><span class="rvts11">, it is treated the same as if you had used </span><span class="rvts18">Get_Arg_Count</span><span class="rvts11"> instead. That makes this a lot shorter and easier to type.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps5"><span class="rvts11">A call like </span><span class="rvts18">Get_Arg$(2,0)</span><span class="rvts11"> is not considered breaking the rule about asking for arguments in ascending order; it's just a short-cut convenience so you don't have to worry so much about exactly how many arguments were present, and so you don't have to type so much.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">Finally, if a call to </span><span class="rvts18">Get_Arg$</span><span class="rvts11"> asks for more arguments than you supplied when you ran the macro, it will only provide the ones that are there. It's not illegal to ask for "too many".</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps5"><span class="rvts11">Just like the single-argument form </span><span class="rvts18">Get_Arg$(0)</span><span class="rvts11">, when you provide two or more macro operands and use </span><span class="rvts18">Get_Arg$(2,0)</span><span class="rvts11"> it returns the requested macro operands so they are separated from each other by a blank.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps2"><span class="rvts13">Putting it all together</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">So, let's finish the job on our macro and flesh it out, adding a bit of error checking as well. </span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">Note that </span><span class="rvts18">Get_Arg$</span><span class="rvts11"> will put spaces </span><span class="rvts33">between</span><span class="rvts11"> the operands it returns, but not before or after. So, in the </span><span class="rvts18">SPF_Cmd</span><span class="rvts11"> expressions, we have to separate the various "pieces" of the expression with a blank so that we end up creating a valid SPFLite primary command; otherwise macro argument 1 and 2 would get "run together" and things wouldn't work right.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">Notice too that we only quote the first argument, but not the remaining ones. Why not? &nbsp;Because we agreed that the "string" argument would always be the first one (remember our discussion from above?) which means the remaining arguments, if there are any, would only be SPFLite keywords like WORD or LAST, which would never be quoted if you wanted to use them as normal keywords and not as data. So, we don't call SPF_Quote$ for them.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps5"><span class="rvts18">' ONLY.MACRO</span></p>
<p class="rvps5"><span class="rvts18">if Get_Arg$(0) &lt;&gt; "" then </span></p>
<p class="rvps5"><span class="rvts18"> &nbsp; SPF_Cmd("EXCLUDE ALL")</span></p>
<p class="rvps5"><span class="rvts18"> &nbsp; SPF_Cmd("FIND ALL " + SPF_Quote$(Get_Arg$(1) + " " + Get_Arg$(2,0)))</span></p>
<p class="rvps5"><span class="rvts18">else</span></p>
<p class="rvps5"><span class="rvts18"> &nbsp; if Get_Curr_Word$ &lt;&gt; "" then </span></p>
<p class="rvps5"><span class="rvts18"> &nbsp; &nbsp; &nbsp;SPF_Cmd("EXCLUDE ALL")</span></p>
<p class="rvps5"><span class="rvts18"> &nbsp; &nbsp; &nbsp;SPF_Cmd("FIND ALL " + SPF_Quote$(Get_Curr_Word$))</span></p>
<p class="rvps5"><span class="rvts18"> &nbsp; else</span></p>
<p class="rvps5"><span class="rvts18"> &nbsp; &nbsp; &nbsp;Halt(FAIL, "There is no word under the cursor")</span></p>
<p class="rvps5"><span class="rvts18"> &nbsp; end if</span></p>
<p class="rvps5"><span class="rvts18">end if</span></p>
<p class="rvps4"><span class="rvts18"><br/></span></p>
<p class="rvps4"><span class="rvts11">Several changes have been made:</span></p>
<ul style="text-indent: 0px; padding: 0; margin: 0 0 0 24px; list-style-position: outside; list-style-type: disc;"><ul style="text-indent: 0px; padding: 0; margin: 0 0 0 48px; list-style-position: outside; list-style-type: circle;">
<li style="margin-left: 0px" class="rvps7"><span class="rvts11">If a command line argument is present, then </span><span class="rvts13">that</span><span class="rvts11"> is what is searched for</span></li>
<li style="margin-left: 0px" class="rvps7"><span class="rvts11">If no command line argument </span><span class="rvts13">and</span><span class="rvts11"> the cursor is on a word, </span><span class="rvts13">that</span><span class="rvts11"> word is searched for</span></li>
<li style="margin-left: 0px" class="rvps7"><span class="rvts11">If no command line argument and the cursor is not on a word, an error message is issued using the </span><span class="rvts18">Set_Msg</span><span class="rvts11"> function</span></li>
<li style="margin-left: 0px" class="rvps7"><span class="rvts11">The smart-quoter function </span><span class="rvts18">SPF_Quote$</span><span class="rvts11"> ensures that if operand 1 is quoted or is a reserved word, it won't cause an incorrect </span><span class="rvts18">FIND</span><span class="rvts11"> command to be created.</span></li>
</ul></ul>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">Our final, fully fleshed-out macro is still only 12 lines, including the header. That's pretty reasonable, and hopefully not too intimidating, even if you're new to writing macros.</span></p>
<p class="rvps2"><span class="rvts11"><br/></span></p>
<p class="rvps2"><span class="rvts11"><br/></span></p>
<p class="rvps2"><span class="rvts13">Simplifying the ONLY macro with NEXCLUDE</span></p>
<p class="rvps2"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">If you look closely, by providing some extra logic to take the context into consideration, you now have a capability that SPFLite doesn't have on its own - even the most current version. Remember we said the basic functionality of ONLY is already covered by the built-in command NEXCLUDE? &nbsp;Well, what ONLY does </span><span class="rvts13">now</span><span class="rvts11"> is actually </span><span class="rvts13">more</span><span class="rvts11"> powerful than NEXCLUDE. But, that doesn't prevent you from actually using NEXCLUDE here. We can eliminate two lines from the macro by replacing EXCLUDE and FIND ALL with NEXCLUDE ALL. </span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">This is a case where having a good familiarity with all of SPFLite's array of available commands can help you write macros that are shorter and run faster. Here is &nbsp;how the revised ONLY macro would now look:</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps7"><span class="rvts14">' ONLY.MACRO</span></p>
<p class="rvps7"><span class="rvts14">'</span></p>
<p class="rvps7"><span class="rvts14">'</span></p>
<p class="rvps7"><span class="rvts14">if Get_Arg$(0) &lt;&gt; "" then </span></p>
<p class="rvps7"><span class="rvts14"> &nbsp;SPF_Cmd("NEXCLUDE ALL " + SPF_Quote$(Get_Arg$(1)) + " " + Get_Arg$(2,0)) </span></p>
<p class="rvps7"><span class="rvts14">else</span></p>
<p class="rvps7"><span class="rvts14"> &nbsp;if Get_Curr_Word$ &lt;&gt; "" then </span></p>
<p class="rvps7"><span class="rvts14"> &nbsp; &nbsp; SPF_Cmd("NEXCLUDE ALL " + SPF_Quote$(Get_Curr_Word$))</span></p>
<p class="rvps7"><span class="rvts14"> &nbsp;else</span></p>
<p class="rvps7"><span class="rvts14"> &nbsp; &nbsp; Halt(FAIL, "There is no word under the cursor")</span></p>
<p class="rvps7"><span class="rvts14"> &nbsp;end if</span></p>
<p class="rvps7"><span class="rvts14">end if</span></p>
<p class="rvps7"><span class="rvts14"><br/></span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps2"><span class="rvts13">Extra credit - Part 1</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">Did you notice how we determined the 'context' of the macro - how it was being used? &nbsp;Calling </span><span class="rvts18">Get_Arg$(0)</span><span class="rvts11"> returns a string with all the arguments provided to the macro. If none were provided, you'd get an empty string. </span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">Suppose your macro is called </span><span class="rvts13">AX.MACRO</span><span class="rvts11">. Under what circumstances would you get an empty string back from </span><span class="rvts18">Get_Arg$(0)</span><span class="rvts11">when you used this macro?</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<ul style="text-indent: 0px; padding: 0; margin: 0 0 0 24px; list-style-position: outside; list-style-type: disc;"><ul style="text-indent: 0px; padding: 0; margin: 0 0 0 48px; list-style-position: outside; list-style-type: circle;">
<li style="margin-left: 0px" class="rvps7"><span class="rvts11">You enter </span><span class="rvts13">AX</span><span class="rvts11"> on the command line by itself with nothing else, to run the macro as a primary command, and press Enter.</span></li>
<li style="margin-left: 0px" class="rvps7"><span class="rvts11">You enter </span><span class="rvts13">AX</span><span class="rvts11"> or </span><span class="rvts13">AXX</span><span class="rvts11"> in the sequence number area of one or two lines, and press Enter. (If you use </span><span class="rvts13">AX</span><span class="rvts11"> as a line-command macro, only one may be specified at a time. If you use </span><span class="rvts13">AXX</span><span class="rvts11"> you must specify it in pairs. Otherwise, SPFLite will detect a usage error.)</span></li>
</ul></ul>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">Is that the </span><span class="rvts13">only</span><span class="rvts11"> way to determine the context? &nbsp;No, there are a few other ways, too:</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<ul style="text-indent: 0px; padding: 0; margin: 0 0 0 24px; list-style-position: outside; list-style-type: disc;"><ul style="text-indent: 0px; padding: 0; margin: 0 0 0 48px; list-style-position: outside; list-style-type: circle;">
<li style="margin-left: 0px" class="rvps7"><span class="rvts11">You can call </span><span class="rvts18">Get_Arg_Count</span><span class="rvts11"> to find out how many arguments were present; if there weren't any, you get 0</span></li>
<li style="margin-left: 0px" class="rvps7"><span class="rvts11">You can call </span><span class="rvts18">Get_Csr_LPTR</span><span class="rvts11"> to find out the line-pointer where the cursor is located; if it's not in the main edit area, you'd get a 0</span></li>
<li style="margin-left: 0px" class="rvps7"><span class="rvts11">You can call </span><span class="rvts18">Get_LNUM(Get_Csr_LPTR))</span><span class="rvts11"> to find out the line-number where the cursor is located; if it's not in the main edit area </span><span class="rvts13">or</span><span class="rvts11"> it's on a non-data line like BNDS or TABS, you'd get a </span><span class="rvts13">0 </span><span class="rvts11">(since lines like BNDS and TABS </span><span class="rvts13">have</span><span class="rvts11"> no line number). This is a little more involved test, but it's a "stronger" one.</span></li>
</ul></ul>
<p class="rvps7"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">You can also see whether your macro was called as a primary-command macro, or as a line-command macro. See </span><a class="rvts12" href="InterfaceStructure.html#Primary%20mode%20vs.%20Line%20mode%20macros">Primary mode vs. Line mode macros</a><span class="rvts11"> for more information.</span></p>
<p class="rvps7"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">Based on your requirements, you'd have to decide how "strict" your test needs to be to ensure it only runs under the right circumstances.</span></p>
<p class="rvps4"><span class="rvts14"><br/></span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps2"><span class="rvts13">Extra credit - Part 2</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">Now that we have created the ONLY macro, fine-tuned its behavior, and taken its operating context into account, what do you think:</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps7"><span class="rvts33">Is </span><span class="rvts11">ONLY</span><span class="rvts33"> a primary-command macro or a line-command macro?</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">Yes, it's a trick question - and the answer is, surprisingly, </span><span class="rvts13">both</span><span class="rvts11">.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">The ONLY macro works quite well when invoked as a line-command macro. If you enter ONLY in the sequence area of a data line, then move the cursor over the word you want as the operand, and press Enter, the macro will function correctly. In fact, the ONLY macro name could be in the sequence area of one line, and the cursor could be on an entirely different line, and it would still work.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps7"><span class="rvts11">What happens? &nbsp;First, the Get_Arg$(0) call will return an empty string, because the macro has no arguments, per se. It then finds a value returned from the call to Get_Curr_Word$, and the macro logic proceeds from that point.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">No, this isn't likely to be a convenient way to type this, and most users would not do it that way, but unless a macro is carefully written to insist on being run only one way or the other, it may very well meet all the requirements for execution as either a primary-command macro or a line-command macro - even if that isn't what you intended when you wrote it.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">Most of the time, you will write a macro with the intent of it only running one way, either as a primary-command macro or a line-command macro, and you may neither know no care that it would work the 'other' way.</span></p>
<p class="rvps4"><span class="rvts11"><br/></span></p>
<p class="rvps4"><span class="rvts11">If you need to be sure, you can use the </span><a class="rvts12" href="FunctionDetails.html#FN.Is_Line_Cmd">Is_Line_Cmd</a><span class="rvts11"> and </span><a class="rvts12" href="FunctionDetails.html#FN.Is_Primary_Cmd">Is_Primary_Cmd</a><span class="rvts11"> functions. See </span><a class="rvts12" href="InterfaceStructure.html#Primary%20mode%20vs.%20Line%20mode%20macros">Primary mode vs. Line mode macros</a><span class="rvts11"> for more information.</span></p>
<p class="rvps4" style="page-break-before: always;"><span class="rvts11"><br/></span></p>
<p></p>
<p class="rvps6" style="clear: both;"><span class="rvts16">Created with the Personal Edition of HelpNDoc: </span><a class="rvts17" href="https://www.helpndoc.com/help-authoring-tool">Create HTML Help, DOC, PDF and print manuals from 1 single source</a></p>

            </div>
            
            
        </div>  <!-- /#topic-content -->
    </article>

    <footer></footer>

  </div>  <!-- /#main -->

  <div class="mask" data-toggle="sm-nav-expanded"></div>
  
  <!-- Modal -->
  <div class="modal fade" id="hndModal" tabindex="-1" role="dialog" aria-labelledby="hndModalLabel">
    <div class="modal-dialog" role="document">
      <div class="modal-content">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
          <h4 class="modal-title" id="hndModalLabel"></h4>
        </div>
        <div class="modal-body">
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-primary modal-btn-close" data-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Scripts -->
  <script src="vendors/jquery-1.11.3/jquery.min.js"></script>
  <script src="vendors/bootstrap-3.3.6/js/bootstrap.min.js"></script>
  <script src="vendors/fastclick-1.0.6/fastclick.min.js"></script>
  <script src="vendors/markjs-8.8.3/jquery.mark.min.js"></script>
  <script src="vendors/uri-1.18.9/uri.min.js"></script>
  <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
  <script src="vendors/bootstrap-3.3.6/js/ie10-viewport-bug-workaround.js"></script>
  
  <!-- Headroom -->
  <script src="vendors/headroom-0.9.3/headroom.min.js"></script>
  <script src="vendors/headroom-0.9.3/jquery.headroom.min.js"></script>

  <!-- JsTree -->
  <script src="vendors/jstree-3.3.2/jstree.min.js"></script>

  <!-- HelpNDoc scripts -->
  <script src="_translations.js"></script>
  <script src="js/hndsd.min.js"></script>
  <script src="js/hndse.min.js"></script>
  <script src="js/app.min.js"></script>

  <!-- Scripts -->
  <script>
    $(function() {
      // Instanciate FastClick
      Origami.fastclick(document.body);
      // Create the app
      var app = new Hnd.App();
      // Update translations
      hnd_ut(app);
	  // Custom JS
	  
      // Boot the app
      app.Boot();
    });
  </script>



</body>

</html>

